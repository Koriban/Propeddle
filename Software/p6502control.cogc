/*
 * p6502control.cogc
 *
 * Control cog for the Propeddle system
 *
 * (C) Copyright 2011-2012 Jac Goudsmit
 * Distributed under the MIT license. See bottom of the file for details.
 */


/////////////////////////////////////////////////////////////////////////////
// INCLUDES
/////////////////////////////////////////////////////////////////////////////


#include "p6502control.h"


/////////////////////////////////////////////////////////////////////////////
// MACROS
/////////////////////////////////////////////////////////////////////////////


// Delay constants for main loop, in Propeller clock cycles
#define P6502_DELAY_MAINLOOP_INIT (91)      // Initial loop min duration
#define P6502_DELAY_MAINLOOP_MINDELAY (80)  // Subsequent loops min duration


/////////////////////////////////////////////////////////////////////////////
// DATA
/////////////////////////////////////////////////////////////////////////////


struct P6502_GLOBALS_T volatile p6502_globals;


/////////////////////////////////////////////////////////////////////////////
// LOCAL FUNCTIONS
/////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------
// Clear current command
//
// By resetting the current command, we let the caller know that we're
// ready for a new command.
static inline void resetcmd(void)
{
    p6502_globals.cmd = P6502_CMD_NONE;
}


//---------------------------------------------------------------------------
// Wait for a new command
//
// Waits until a new command arrives in the global data.
// The function returns with the new command.
static inline P6502_CMD waitforcmd(void)
{
    P6502_CMD result;
    
    while ((result = p6502_globals.cmd) == P6502_CMD_NONE)
    {
        // Nothing to do here
    }
    
    return result;
}


//---------------------------------------------------------------------------
// Send signals from global data to the 6502
//
// Only the actual signal bits in the global signals data are used, other 
// bits are ignored.
// On entry, the DIR register should have the signal bits set for output.
_NATIVE
static void sendsignals(unsigned signals)
{
    __asm__ __volatile__(
"\n                 and     %[signals], %[mask_SIGNALS]"
"\n                 andn    OUTA,       %[mask_SLC_SIGNALS]"
"\n                 or      OUTA,       %[signals]"
"\n                 nop     "                           // Do not remove
"\n                 or      OUTA,       %[mask_SLC]"

:
    [signals]               "+rC"       (signals)
:
    [mask_SIGNALS]          "rC"        (P6502_MASK_SIGNALS),
    [mask_SLC_SIGNALS]      "rC"        (P6502_MASK_SIGNALS | pmask(pin_SLC)),
    [mask_SLC]              "rC"        (pmask(pin_SLC))
:
    );
}


//---------------------------------------------------------------------------
// Shut down the control cog
//
// The global command is reset to NONE to indicate that the cog has stopped.
#ifdef P6502_CONTROLCOG_SHUTDOWN
_NATIVE
static void cmd_shutdown(void)

{
    __asm__ __volatile__(
"\n                 mov     OUTA,       %[out_INIT]"
"\n                 nop     "
"\n                 or      OUTA,       %[mask_SLC]"

:
:
    [out_INIT]              "rC"        (P6502_MASK_OUT_INIT),
    [mask_SLC]              "rC"        (pmask(pin_SLC))
:
    );

    resetcmd(); // Let caller know we're stopping
    
    cogstop(cogid());
}
#endif


//---------------------------------------------------------------------------
// Disconnect from I2C bus
//
// Stops the cog from using the SCL line which is shared with the I2C bus.
// This makes it possible (and is necessary) to use the I2C bus for other
// purposes including XMM programming.
// Normally the control cog holds SDA high and uses SCL as clock for the
// 6502, but while the control cog is in disconnected state, it doesn't use
// the SDA/SCL lines at all.
// To prevent the 6502 from running on clock signals from other cogs, it is
// halted by activating the RDY signal.
#ifdef P6502_CONTROLCOG_I2C
_NATIVE
static P6502_CMD cmd_disconnect_i2c(void)
{
    P6502_CMD result;
    
    // Activate RDY to halt the 6502
    sendsignals(p6502_globals.signals & ~pmask(pin_RDY));
    
    _DIRA &= ~P6502_MASK_I2C;
    resetcmd();
    result = waitforcmd();
    _DIRA = P6502_MASK_DIR_INIT;
    
    sendsignals(p6502_globals.signals);
    
    return result;
}
#endif


//---------------------------------------------------------------------------
// Run the 6502 at the desired speed, until told to stop
_NATIVE
static void cmd_run(void)
{
    // Let the calling cog know we're working
    p6502_globals.retval = 0;
    p6502_globals.cmd = P6502_CMD_NUM; // Don't use NONE; we're busy, not done
    
    // Copy input parameters from globals
    unsigned cycletime = p6502_globals.cycletime;
    unsigned counter   = p6502_globals.counter;
    
    // Output parameters
    volatile unsigned *psignals = &p6502_globals.signals;
        
    // Locals
    unsigned signals = *psignals;
    unsigned retval;
    unsigned clock;

    __asm__ __volatile__(
                    // Read the time that each 6502 cycle should take.
                    // Store this in the variable that's used to
                    // increment the clock in the waitcnt instruction.
                    // Make sure the value is at least equal to the
                    // minimum execution time for non-first loops.
"\n                 min     %[cycletime], %[MINDELAY]"
"\n"
                    // Initialize the clock to cycle time, but minimize
                    // this by the minimum time for the first cycle
                    // Note, CNT is added just before jumping into the
                    // loop.
"\n                 mov     %[clock],   %[cycletime]"
"\n                 min     %[clock],   %[MININITDELAY]"
"\n"
                    // Read the number of clock cycles to execute.
                    // Depending on whether the count is 0, enable or
                    // disable the check at the end of the loop.
                    // In other words, if z=1 here, change the
                    // djnz instruction so that the result is never
                    // written.
                    // These instructions also reset the Z flag so it's
                    // set to 0 if the firsst iteration of the loop
                    // exits on a pseudo-interrupt right away.
"\n                 cmp     %[counter], #0 wz"
"\n                 muxnz   LoopIns,    %[mux_R] wz" // reset Z flag
"\n"
                    // Add the system clock to the local clock. This
                    // should be done just before jumping into the loop.
"\n                 add     %[clock],   CNT"
"\n                 jmp     #StartMainLoop"
"\n"
//===========================================================================
// Main loop: generate clock cycles to let the 65C02 run its program

// NOTE: The following code was meticulously constructed to generate a loop
// that executes at 1MHz when the Propeller runs at 80MHz. When the Propeller
// runs at 100MHz, the 65C02 can be run at up to 1.25MHz.
// The timing was based on the 65C02 datasheet from Western Design Center.
//
// It is important to keep in mind that other cogs may depend on the timing
// of this cog too; for example while this cog doesn't actually read the
// address bus, it enables the address bus at a certain point in time, and
// other cogs can only read it during that short time.
//
// Timings in comments are Propeller clock cycles; t=0 corresponds to the
// start of Phi1 (CLK0 changes from high to low). t0 represents timing on
// the first iteration, tn represents timing on subsequent iterations. All
// timings are based on a minimum duration for the waitcnt instruction.
//
// The first iteration of the loop may take longer than subsequent
// iterations because the hub instruction may take longer during the first
// execution of the code. However, after the first iteration, all subsequent
// iterations take the same amount of time: 80 Propeller clock cycles. A
// timing analysis document is available to prove this.
"\nMainLoop"
                    // Wait for the end of the requested cycle time
                    // Initialization may change the instruction at the end
                    // of the loop so that this instruction is skipped.
//t0=67..82
//tn=67
"\n                 waitcnt %[clock],   %[cycletime]"
"\n"
                    // Turn off the Write Enable to the RAM
                    // We could do this at the same time as setting the
                    // clock low, however it's not possible to change two
                    // bits to different values at the same time without
                    // touching other bits, except with an xor instruction
                    // and in order to use an xor we would need to be
                    // sure that the current bit is 0, but this is only the
                    // case if the 6502 is in a write-operation.
                    // We have to disable the RAM before setting the clock,
                    // because if we'd do it the other way around, there
                    // would be a chance that the 6502 changes the address
                    // bus and clobbers the RAM.
//t0=72..87
//tn=72
"\n                 or      OUTA,       %[mask_RAMWE]"
"\n"
                    // Set the clock LOW
                    // This starts the PHI1 part of the clock cycle, unless
                    // one of the other cogs makes the clock high too.
                    // We will check for that next.
//t0=76..91
//tn=76
"\n                 andn    OUTA,       %[mask_CLK0]"
"\n"
                    // Check if another cog is keeping the clock in the high
                    // state, indicating that they want us to stop running.
                    // If that is the case, we break out of the loop here.
                    // Because the outputs are retained between our change of
                    // the CLK0 output and here, it's possible to restart the
                    // loop without need to worry about the 6502.
                    // The other cogs that depend on the timing of this cog
                    // can also safely keep running: they are just as unaware
                    // of the fact that we couldn't change the CLK0 output to
                    // low as the 6502 is.
//t0=0
//tn=0
"\nStartMainLoop"
"\n                 test    INA,        %[mask_PINT] wc"
"\n     if_c        jmp     #EndMainLoop"
"\n"
                    // Initialize all output signals:
                    // - The RAM is disabled; this has to happen a short time
                    //   after setting the clock low, so that the 6502 has
                    //   time to read the data bus. Normally it would be
                    //   sufficient to turn the RAM off at the same time as
                    //   switching the clock, however this is impossible
                    //   (see above).
                    // - The signals in the OUTA register are initialized to
                    //   0 so it's possible to OR the signals from the hub in
                    //   there.
                    // - The clock for the signal flipflops (SLC) is reset so
                    //   that all it takes to get them to the 6502 again is
                    //   to turn SLC on again.
                    // - The address buffers are enabled so other cogs can
                    //   read the address from P0..P15
//t0=8
//tn=8                    
"\n                 mov     OUTA,       %[mask_PHI1]"
"\n"
                    // It takes a little while before the address can be read
                    // reliably because of setup time and propagation delays.
                    // Also we want to give the other cogs some time to pick
                    // up the address, so we check the read/write output of
                    // the 6502 here, and then wait for one instruction time.
//t0=12
//tn=12
"\n                 test    INA,        %[mask_RW] wc" // c=1 read, c=0 write
"\n                 nop"
"\n"
                    // Turn the address buffers off again, and output the 
                    // signals to the flip-flops on P8..P15. They need a little
                    // time to settle and we also want to give other cogs the
                    // opportunity to override them so there's some extra
                    // delay in there.
//t0=20
//tn=20
"\n                 or      OUTA,       %[mask_AEN]"
"\n                 or      DIRA,       %[mask_SIGNALS]"
"\n                 or      OUTA,       %[signals]"
"\n                 nop"
"\n"
                    // Clock the flip-flops to send the signals to the 6502.
//t0=36
//tn=36
"\n                 or      OUTA,       %[mask_SLC]"
"\n"
                    // Set the clock HIGH
                    // This starts the PHI2 part of the clock cycle.
                    // Note: it's possible to combine this instruction with
                    // the previous one, but the SO signal is picked up by
                    // the 6502 at the start of PHI2 (the other signals are
                    // picked up later) so by clocking the flipflops before
                    // switching CLK0, we guarantee that the delay for all
                    // signals is minimal.
//t0=40
//tn=40
"\n                 or      OUTA,       %[mask_CLK0]"
"\n"
                    // Remove the signals from P8..P15
//t0=44
//tn=44
"\n                 andn    DIRA,       %[mask_SIGNALS]"
"\n"
                    // Get the signals from the hub
                    // The signals must be clean, i.e. no non-signal bits
                    // should be set.
//t0=48
//tn=48
"\n                 rdlong  %[signals], %[psignals]"                    
"\n"
                    // Enable the RAM chip, either for write or for read,
                    // depending on whether the 6502 is in read or write
                    // mode. By now the other cogs should have had plenty
                    // of time to check the address, and possibly override
                    // the RAM outputs (i.e. turn them off) and take
                    // their own actions, such as redirecting to/from the
                    // hub or making sure the RAM cannot be overwritten.
//t0=55..62
//tn=55
"\n     if_nc       andn    OUTA, %[mask_RAMWE]"
"\n     if_c        andn    OUTA, %[mask_RAMOE]"
"\n"
                    // We reached the end of the loop.
                    // If we're supposed to execute a limited number of
                    // instructions, the counter is decreased here and we
                    // leave the loop when it reaches zero.
                    // If we run without limitation, the initialization
                    // code changes the instruction so it doesn't store
                    // the result (NR), so this loops forever.
//t0=59..66
//tn=59
"\nLoopIns"
"\n                 djnz    %[counter], #MainLoop wz"
"\n"

//===========================================================================
    
                    // We dropped out of the loop
                    // Make sure the last cycle's duration is the same
                    // as all other cycles
"\n                 waitcnt %[clock],   %[cycletime]"
"\nEndMainLoop"
"\n"
                    // The Z flag was set by the loop if it was terminated
                    // after a predetermined number of instructions.
                    // Otherwise, it was terminated by pseudo-interrupt.
"\n                 mov     %[retval],  #0"
"\n                 muxz    %[retval],  #1"     // retval & 1 indicates terminated

:
    [counter]               "+rC"   (counter),
    [retval]                "=rC"   (retval)
:
    // Locals
    [clock]                 "rC"    (clock),
    [cycletime]             "rC"    (cycletime),
    [signals]               "rC"    (signals),
    [psignals]              "rC"    (psignals),
    
    // Masks
    [dir_INIT]              "rC"    (P6502_MASK_DIR_INIT),
    [out_INIT]              "rC"    (P6502_MASK_OUT_INIT),
    [mux_R]                 "rC"    (0b00000000100000000000000000000000),
    [mask_AEN]              "rC"    (pmask(pin_AEN)),
    [mask_CLK0]             "rC"    (pmask(pin_CLK0)),
    [mask_PHI1]             "rC"    (P6502_MASK_OUT_PHI1),
    [mask_PINT]             "rC"    (pmask(pin_PINT)),
    [mask_RAMOE]            "rC"    (pmask(pin_RAMOE)),
    [mask_RAMWE]            "rC"    (pmask(pin_RAMWE)),
    [mask_RW]               "rC"    (pmask(pin_RW)),
    [mask_SIGNALS]          "rC"    (P6502_MASK_SIGNALS),
    [mask_SLC]              "rC"    (pmask(pin_SLC)),
    
    // Immediates
    [MINDELAY]              "i"     (P6502_DELAY_MAINLOOP_MINDELAY),
    [MININITDELAY]          "i"     (P6502_DELAY_MAINLOOP_INIT)
:
    );
    
    // Store locals back in global struct
    p6502_globals.counter = counter;
    p6502_globals.retval  = retval;
}


/////////////////////////////////////////////////////////////////////////////
// PUBLIC FUNCTIONS
/////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------
// Main program for the control cog
//
// The control cog communicates with the rest of the program through the
// global data structure. There should never be more than on instance of the
// control cog.
//
// Basically, the command in the global data can be used to detect whether
// the control cog is ready for a new command, as well as to send such a
// command. The parameters to the command are passed through the global
// data struct too, as well as any possible return values.
//
// The calling cog should use a lock to prevent contention between multiple
// callers trying to send a command at the same time. The lock can also be
// used to safely store the return values when a command is completed.
_NAKED
void main(void)
{
    P6502_CMD cmd = P6502_CMD_NONE;

    _DIRA = P6502_MASK_DIR_INIT;
    _OUTA = P6502_MASK_OUT_INIT;

    sendsignals(p6502_globals.signals);

    resetcmd();
    
    while (p6502_globals.cmd)
    {
        // Get a new command unless we already have one
        if (cmd == P6502_CMD_NONE)
        {
            cmd = waitforcmd();
        }
        
        // Execute the command
        switch(cmd)
        {
        case P6502_CMD_NONE:
            // Nothing to do (we shouldn't get here)
            break;
            
#ifdef P6502_CONTROLCOG_SHUTDOWN
        case P6502_CMD_SHUTDOWN:
            cmd_shutdown();
            break;
#endif
      
#ifdef P6502_LED
        case P6502_CMD_LED_ON:
            _OUTA |= P6502_MASK_LED;
            break;
            
        case P6502_CMD_LED_OFF:
            _OUTA &= ~P6502_MASK_LED;
            break;
            
        case P6502_CMD_LED_TOGGLE:
            _OUTA ^= P6502_MASK_LED;
            break;
#endif

#ifdef P6502_CONTROLCOG_DEBUG
        case P6502_CMD_GET_INA:
            p6502_globals.retval = _INA;
            break;
            
        case P6502_CMD_GET_OUTA:
            p6502_globals.retval = _OUTA;
            break;
#endif

#ifdef P6502_CONTROLCOG_I2C
        case P6502_CMD_DISCONNECT_I2C:
            cmd = cmd_disconnect_i2c();
            continue; // function already retrieved command
#endif

        case P6502_CMD_SET_SIGNALS:
            sendsignals(p6502_globals.signals);
            break;

        case P6502_CMD_RUN:
            cmd_run();
            break;
            
        default:
            ; // Ignore bad commands
        }
        
        resetcmd(); // Let caller know we're done
        cmd = P6502_CMD_NONE;
    }
}


/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////


/*
    __asm__(
"//============================================================================"
"// Download data from the hub to the RAM"
""
"CmdDownload"
                        "// Initialize parameters"
                        "rdlong  hubaddr, parm_pHubAddr"
                        "rdlong  hublen, parm_pHubLen wz"
                        "rdlong  startaddr, parm_pAddr"
                        "rdlong  cycletime, parm_pCycleTime"
"                        "
                        "// If nothing to do, return"
              "if_z      jmp     #CommandDone"
"              "
                        "// Initialize timer"
                        "min     cycletime, #con_delay_MAINLOOP_MINDELAY"
""
                        "// Initialize state machine"
                        "// Z is always 0 at this time"
                        "// For the first state, there is no address matching"
                        "muxnz   :addrmatch, mux_Z_TO_ALWAYS"
                        "movs    :addrmatch, #:state_nmi"
                        "movs    :loopins, #:loop"
""
                        "//-------------------------------                        "
                        "// Downloading state machine starts here"
":loop                        "
                        "// Start Phi1"
                        "mov     OUTA, out_PHI1"
""
                        "// Wait for address bus to stabilize"
                        "// Meanwhile, initialize direction and test for"
                        "// read/write."
                        "andn    DIRA, mask_ADDR"
                        "test    INA, mask_RW wc"
""
                        "// Get address"
                        "mov     addr, INA"
                        "and     addr, mask_ADDR"
""
                        "// Disable address latches                                "
                        "or      OUTA, mask_AEN"
""
                        "// If the address matches the currently expected"
                        "// address, jump to the currently defined state"
                        "cmp     addr, expectedaddr wz"
":addrmatch    if_z      jmp     #(0)                    // Modified to jump depending on state"
""
                        "//-------------------------------"
                        "// The address doesn't match"
                        "// Enable the RAM based on the R/W signal"
":doram        if_c      andn    OUTA, mask_RAMOE        // RAM to 65C02"
              "if_nc     andn    OUTA, mask_RAMWE        // 65C02 to RAM"
""
                        "// Start Phi2"
":loopphi2                        "
                        "or      OUTA, mask_CLK0"
""
                        "// Nothing to do during Phi2"
":loopwait"
                        "// Wait for the entire cycle time"
                        "mov     clock, CNT"
                        "add     clock, cycletime"
                        "waitcnt clock, #0"
":loopins                jmp     #(:loop)                // Changed to CommandDone"
                                                        "// when done"
""
                        "//-------------------------------"
                        "// Feed a byte to the 6502 during Phi2"
":feedbyte6502"
                        "or      OUTA, feedbyte          // 16 bits or'ed, upper 8 bits ignored"
                        "or      DIRA, mask_DATA         // because of this DIRA setting"
                        "or      OUTA, mask_CLK0         // Start Phi2"
""
                        "jmp     #:loopwait                        "
""
                        "//-------------------------------"
                        "// Initial state: Activate NMI"
":state_nmi"
                        "// Restore the jmp instruction"
                        "or      DIRA, mask_SIGNALS wz   // Z is always 0"
                        "muxz    :addrmatch, mux_Z_TO_ALWAYS // Change back to if_z"
""
                        "// Generate NMI (which is edge triggered)"
                        "andn    signals, mask_NMI"
                        "call    #SendSignals"
""
                        "// Change state when NMI vector appears"
                        "mov     expectedaddr, vector_NMI"
                        "movs    :addrmatch, #:state_vector1"
""
                        "// Finish as normal cycle"
                        "jmp     #:loopphi2"
"                        "
                        "//-------------------------------"
                        "// 6502 is fetching low part of vector"
":state_vector1"
                        "// Next time, check for the second half of the vector"
                        "add     expectedaddr, #1"
                        "movs    :addrmatch, #:state_vector2"
""
                        "// Feed the low byte of the start address to the 6502"
                        "// Note, bits 8-15 are ignored because of DIRA setting"
                        "// We use this to store the value temporarily"
                        "mov     feedbyte, startaddr"
""
                        "jmp     #:feedbyte6502"
"                        "
                        "//-------------------------------"
                        "// 6502 is fetching high part of vector"
":state_vector2"
                        "// Next time, check for the start address of our area"
                        "mov     expectedaddr, startaddr"
                        "movs    :addrmatch, #:state_writedata"
""
                        "// Feed the high byte of the start address to the 6502"
                        "shr     feedbyte, #8"
                        "jmp     #:feedbyte6502"
""
                        "//-------------------------------"
                        "// 6502 is iterating our target area"
":state_writedata"
                        "// Next time, expect the address to be one higher"
                        "// but stay in this state"
                        "add     expectedaddr, #1"
""
                        "// Get data from the hub at the current location "
                        "rdbyte  data, hubaddr"
""
                        "// Put data from hub on data bus"
                        "or      OUTA, data"
                        "or      DIRA, mask_DATA"
""
                        "// Activate the RAM"
                        "andn    OUTA, mask_RAMWE"
""
                        "// Wait for RAM to store the data"
                        "// Meanwhile, do some housekeeping"
                        "add     hubaddr, #1"
                        "sub     hublen, #1 wz"
              "if_z      jmp     #:endwrite                                                        "
""
                        "// Deactivate RAM"
                        "or      OUTA, mask_RAMWE"
""
                        "// Feed a CMP Immediate instruction to the 6502."
                        "mov     feedbyte, #$C9          // CMP IMMEDIATE"
                        "jmp     #:feedbyte6502"
""
                        "//-------------------------------"
                        "// Finishing up after last write-cycle"
                        "// Z=1 at this time"
":endwrite"
                        "// Deactivate NMI"
                        "or      DIRA, mask_SIGNALS"
                        "or      signals, mask_NMI"
                        "call    #SendSignals"
""
                        "// From now on, disregard match to expected address"
                        "// and always jump to the state function"
"                        movs    :addrmatch, #:state_endwrite"
                        "muxz    :addrmatch, mux_Z_TO_ALWAYS // disregard address from now on"
""
                        "// Feed RTI to the 6502"
":feedRTI                mov     feedbyte, #$40          // RTI"
                        "jmp     #:feedbyte6502"
                                                ""
                        "//-------------------------------"
                        "// Done writing bytes to RAM"
":state_endwrite"
                        "// We're now sending RTI instructions to the 6502."
                        "// We do this until the current address doesn't match"
                        "// the expected address anymore, which means that the"
                        "// 6502 is fetching the flags and return address from"
                        "// the stack."
              "if_z      add     expectedaddr, #1"
              "if_z      jmp     #:feedRTI"
""
                        "// Break out of the loop after finishing Phi2"
                        "movs    :loopins, #CommandDone"
                        "jmp     #:doram          "
"                        "
*/


/////////////////////////////////////////////////////////////////////////////
// TERMS OF USE: MIT LICENSE
/////////////////////////////////////////////////////////////////////////////


/* Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
 
 
/////////////////////////////////////////////////////////////////////////////
// END
/////////////////////////////////////////////////////////////////////////////
